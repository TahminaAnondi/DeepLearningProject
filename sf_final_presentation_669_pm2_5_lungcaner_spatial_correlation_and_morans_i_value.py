# -*- coding: utf-8 -*-
"""SF-Final_Presentation_669_PM2.5_LungCaner_Spatial_Correlation_and_Morans_I_value.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oPtdPShG1Kf6rsxWoGI2Byp_d42eALFM
"""

!pip install pysal

!pip install contextily

import pandas as pd
import geopandas as gpd
import folium
from pysal.explore import esda
from pysal.lib import weights
from ipywidgets import interact, IntSlider
import matplotlib.pyplot as plt
import contextily as ctx
import os
# Load the Louisiana parish boundary data
parishes_geo = gpd.read_file('/content/Louisiana_Parishes.shp')

# Specify the parishes of interest
parishes = ['Ascension', 'Caddo', 'Calcasieu', 'East Baton Rouge', 'Iberville',
            'Jefferson', 'Lafayette', 'Ouachita', 'Rapides', 'St. Bernard',
            'Tangipahoa', 'Terrebonne', 'West Baton Rouge']

# Filter the parishes_geo GeoDataFrame to include only the parishes present in the datasets
parishes_geo_filtered = parishes_geo[parishes_geo['Name'].isin(parishes)]

def create_maps(year):
    # Load the PM2.5 data for the selected year
    pm25_file = f'/content/pm2.5_{year}.csv'
    data = pd.read_csv(pm25_file)
    print(data)
    if os.path.exists(pm25_file):
      data = pd.read_csv(pm25_file)
    else:
      print(f"File not found: {pm25_file}")
    # Load the lung cancer data for the selected year
    cancer_file = f'/content/lung_cancer_{year}.csv'
    cancer_data = pd.read_csv(cancer_file)
    print(cancer_data)
    # Filter the data for the selected year and specified parishes
    data_filtered = data[(data['Year'] == year) & (data['Name'].isin(parishes))]
    cancer_data_filtered = cancer_data[(cancer_data['Year'] == year) & (cancer_data['Name'].isin(parishes))]

    # Merge the PM2.5 data with the filtered parish boundary data
    merged_data = parishes_geo_filtered.merge(data_filtered, left_on='Name', right_on='Name')

    # Merge the lung cancer data
    merged_data = merged_data.merge(cancer_data_filtered, left_on='Name', right_on='Name')

    # Calculate Moran's I for spatial autocorrelation
    w = weights.Queen.from_dataframe(merged_data)
    moran_pm25 = esda.Moran(merged_data['Mean'], w)
    moran_cancer = esda.Moran(merged_data['Rate'], w)

    # Create the non-interactive map
    fig, ax = plt.subplots(figsize=(10, 8))
    merged_data.plot(ax=ax, edgecolor='black', column='Rate', cmap='Reds', legend=True)
    merged_data.centroid.plot(ax=ax, markersize=merged_data['Mean'], color='black', alpha=0.7)
    ctx.add_basemap(ax)
    ax.set_title(f'PM2.5 Mean for Louisiana Parishes in {year}')
    ax.set_axis_off()

    # Create the interactive map centered on Louisiana
    louisiana_coords = [30.9843, -91.9623] # Coordinates for the center of Louisiana
    interactive_map = folium.Map(location=louisiana_coords, zoom_start=7)

    # Add the filtered parish polygons to the map
    folium.GeoJson(
        parishes_geo_filtered,
        name='Parishes',
        style_function=lambda feature: {
            'fillColor': 'white',
            'color': 'black',
            'weight': 1,
            'fillOpacity': 0.2
        }
    ).add_to(interactive_map)

    # Add parish polygons to the map and shade them based on lung cancer rates
    folium.Choropleth(
        geo_data=merged_data,
        name='Lung Cancer Rates',
        data=merged_data,
        columns=['Name', 'Rate'],
        key_on='feature.properties.Name',
        fill_color='YlOrRd',
        fill_opacity=0.7,
        line_opacity=0.2,
        legend_name='Lung Cancer Rates'
    ).add_to(interactive_map)

    # Create a feature group for PM2.5 mean values
    pm25_group = folium.FeatureGroup(name='PM2.5 Mean Values')

    # Add red circles for PM2.5 mean values
    for idx, row in merged_data.iterrows():
        folium.Circle(
            location=[row.geometry.centroid.y, row.geometry.centroid.x],
            radius=5000, # Adjust the radius as needed
            color='red',
            fill=True,
            fill_color='red',
            fill_opacity=1,
            tooltip=f"Parish: {row['Name']}<br>PM2.5 Mean: {row['Mean']:.2f}"
        ).add_to(pm25_group)

    # Add the PM2.5 feature group to the map
    pm25_group.add_to(interactive_map)

    # Add a layer control to the map
    folium.LayerControl().add_to(interactive_map)

    # Display Moran's I values
    print(f"Moran's I for PM2.5 in {year}: {moran_pm25.I:.4f}")
    print(f"Moran's I p-value for PM2.5 in {year}: {moran_pm25.p_sim:.4f}")
    print(f"Moran's I for Lung Cancer Rates in {year}: {moran_cancer.I:.4f}")
    print(f"Moran's I p-value for Lung Cancer Rates in {year}: {moran_cancer.p_sim:.4f}")

    return fig, interactive_map

# Create the interactive dashboard
@interact(year=IntSlider(min=2011, max=2020, step=1, value=2011))
def display_dashboard(year):
    fig, interactive_map = create_maps(year)
    plt.show(fig)
    display(interactive_map)

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
import plotly.graph_objects as go

# Load PM2.5 data
pm25_file = '/content/Monthly_PM25_Values_2011_2021.csv'
pm25_data = pd.read_csv(pm25_file)

# Split the 'Date' column into 'Year' and 'Month' columns
pm25_data[['Year', 'Month']] = pm25_data['Date'].str.split('/', expand=True)
# Check for missing values in the 'Year' column
missing_values = pm25_data['Year'].isnull().sum()
if missing_values > 0:
    print("There are missing values in the 'Year' column.")
# Drop rows with missing values in the 'Year' column
pm25_data.dropna(subset=['Year'], inplace=True)
# Recalculate last_date_year after handling missing values
last_date_index = pm25_data.index[-1]
last_date_year = int(pm25_data.loc[last_date_index, 'Year'])

# Preprocess data for LSTM
pm25_values = pm25_data['PM2.5'].values.reshape(-1, 1)  # 'PM2.5' column contains mean PM2.5 values
scaler = MinMaxScaler(feature_range=(0, 1))
pm25_scaled = scaler.fit_transform(pm25_values)
#PM2.5 Data: [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65]
#if time steps 3
#X = [[10, 15, 20], [15, 20, 25], [20, 25, 30], [25, 30, 35], ...]
# y = [25, 30, 35, 40, ...]

# Prepare data for LSTM (3D input)
time_steps = 10  # Define the number of time steps (adjust as needed)
X = []
y = []
for i in range(len(pm25_scaled) - time_steps):
    X.append(pm25_scaled[i:i+time_steps, 0])
    y.append(pm25_scaled[i+time_steps, 0])

X = np.array(X)
y = np.array(y)

# Reshape data for LSTM (samples, time steps, features)
X = np.reshape(X, (X.shape[0], X.shape[1], 1))

# Define and compile the LSTM model
model = Sequential()
model.add(LSTM(units=50, return_sequences=True, input_shape=(X.shape[1], 1)))
model.add(LSTM(units=50))
model.add(Dense(units=1))

model.compile(optimizer='adam', loss='mean_squared_error')

# Train the LSTM model
model.fit(X, y, epochs=100, batch_size=32)

# Make predictions for January 2022 (monthly predictions)
predicted_values = []
initial_sequence = X[-1]  # Initial sequence for prediction
for _ in range(1):  # Predicting for January 2022
    predicted_value = model.predict(initial_sequence.reshape(1, time_steps, 1))
    predicted_values.append(predicted_value.flatten()[0])  # Append predicted value
    initial_sequence = np.append(initial_sequence[1:], predicted_value)  # Update sequence for next prediction

# Inverse transform the predictions (if needed)
predicted_values = np.array(predicted_values).reshape(-1, 1)
predicted_values = scaler.inverse_transform(predicted_values)

# Get latitude and longitude for each parish
parish_latitudes = pm25_data['Latitude'].values
parish_longitudes = pm25_data['Longitude'].values
parish_names = pm25_data['Parish'].values  # Get parish names

# Create a Plotly scattermapbox plot for the predicted values
fig = go.Figure(go.Scattermapbox(
    lat=parish_latitudes,
    lon=parish_longitudes,
    mode='markers',
    marker=go.scattermapbox.Marker(
        size=10,
        color=predicted_values.flatten(),  # Color based on predicted PM2.5 values
        colorscale='Viridis',  # Choose a colorscale
        colorbar=dict(title='Predicted PM2.5 Values')
    ),
    text=parish_names,  # Tooltip text (Parish names)
))

fig.update_layout(
    title='Predicted PM2.5 Values for Parishes in January 2022',
    mapbox=dict(
        style='carto-positron',
        zoom=5,
        center=dict(lat=30.4583, lon=-91.1403),  # Set the center of the map
    ),
)

fig.show()